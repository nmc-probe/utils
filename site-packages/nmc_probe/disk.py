# Copyright (c) 2015 The New Mexico Consortium
# 
# {{{NMC-LICENSE
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.
#
# }}}

import sys, os, re

from nmc_probe.hdparm import HDParm
from nmc_probe.smart import Smart
from nmc_probe.proc.diskstats import Diskstats

class Disk:
    @classmethod
    def all_sd(cls):
        '''Get information about all disks and find the corresponding /dev/disk/by-id and by-path information.
        Excludes partitions and devices not named ^sd[a-zA-Z]+$'''
        disks = []
        for key, value in Diskstats.info().iteritems():
            if re.match('^sd[a-zA-Z]+$', key):
                disks.append(Disk('/dev/%s' % key))
        
        return disks

    @classmethod
    def all_sd_sn_map(cls):
        '''Return a map of all disks, key is serial number, value is a Disk object'''
        disk_list = Disk.all_sd()

        disk_map = {}

        for disk in disk_list:
            disk_map[disk.serial_number] = disk

        return disk_map

    @classmethod
    def all_sd_wwn_map(cls):
        '''Return a map of all disks, key is wwn, value is a Disk object'''
        disk_list = Disk.all_sd()

        disk_map = {}

        for disk in disk_list:
            wwn = getattr(disk, 'wwn', None)
            if wwn is not None:
                disk_map[wwn] = disk

        return disk_map
        
    def __init__(self, dev):
        '''Constructor'''
        # Verify that the device exists
        stat = os.stat(dev)

        self.dev = dev
        self.hdparm = HDParm(dev)
        self.smart = Smart(dev)

        # Record this device's inode
        self.inode = stat.st_ino

        # Set the protocol. This should be discovered, but for now, we hard code it to ata
        # until I can find a good way of doing this
        self.protocol = 'ata'

        for key, value in self.hdparm.info.iteritems():
            setattr(self, key, value)

    @property
    def dev_by_id_wwn(self):
        '''/dev/disk/by-id/wwn-'''
        if getattr(self, '_dev_by_id_wwn', None) is None:
            self._dev_by_id_wwn = self.get_dev_by_id_wwn(self.wwn, self.inode)
        return self._dev_by_id_wwn

    def get_dev_by_id_wwn(self, wwn, expected_inode):
        '''Find /dev/disk/by-id/wwn- 

        Params
        ------
        wwn: string
           The wwn of the disk
        expected_inode: string
           The expected inode of the resulting device. This is used as a sanity check
        '''

        dev = '/dev/disk/by-id/wwn-0x%s' % wwn

        # Check to see if the device exists. If it doesn't, an exception will be thrown
        stat = os.stat(dev)

        # Make sure that this device is pointing to the expected inode
        if stat.st_ino != expected_inode:
            raise Exception('Expected %s to have inode %s, instead it has inode %s' % (dev, expected_inode, stat.st_ino))
        
        return dev

    @property
    def id_sn(self):
        if getattr(self, '_id_sn', None) is None:
            self._id_sn = self.dev_by_id_sn.split('/')[-1]
        return self._id_sn

    @property
    def dev_by_id_sn(self):
        '''The path to this disk in /dev/disk/by-id/protocol-model-serial number'''
        if getattr(self, '_dev_by_id_sn', None) is None:
            self._dev_by_id_sn = self.get_dev_by_id_sn(self.protocol, self.model_number, self.serial_number, self.inode)
        return self._dev_by_id_sn

    def get_dev_by_id_sn(self, protocol, model_number, serial_number, expected_inode):
        '''Find /dev/disk/by-id/wwn- 

        Params
        ------
        protocol: string
           The protocol of the disk. Only SATA and SAS are handled.
        model_number: string
           The model of the disk
        serial_number: string
           The serial number of the disk
        expected_inode: string
           The expected inode of the resulting device. This is used as a sanity check
        '''
        # Impose sanity
        model_number = model_number.replace(' ', '_')
        serial_number = serial_number.replace(' ', '_')

        if protocol == 'SATA' or protocol == 'ata':
            protocol = 'ata'
        elif protocol == 'SAS':
            protocol = 'sas'
        else:
            raise Exception('Protocol %s not recognized, cannot find /dev/disk/by-id/PROTOCOL')

        dev = '/dev/disk/by-id/%s-%s_%s' % (protocol, model_number, serial_number)

        # Check to see if the device exists. If it doesn't, an exception will be 
        # thrown
        stat = os.stat(dev)

        # Make sure that this device is pointing to the expected inode
        if stat.st_ino != expected_inode:
            raise Exception('Expected %s to have inode %s, instead it has inode %s' % (dev, expected_inode, stat.st_ino))
        
        return dev

    @property
    def speed(self):
        return self.hdparm.speed
