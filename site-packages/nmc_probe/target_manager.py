# Copyright (c) 2015 The New Mexico Consortium
#
# {{{NMC-LICENSE
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.
#
# }}}

import re
import subprocess
from rtslib_fb import FabricModule, Target, TPG, BlockStorageObject
from rtslib_fb import NetworkPortal, NodeACL, LUN, MappedLUN, RTSRoot

from nmc_probe.log import Log


class TargetManager:
    'Manages ZVOL based iSCSI targets for Emulab diskless booting'

    # Constructor
    def __init__(self):
        self.block_store = {}
        self.target = {}
        self.root = RTSRoot()
        self.iscsi = FabricModule('iscsi')
        self.mapped_luns = {}

        self.get_block_store_objects()
        self.get_targets()

    def save(self):
        '''Save the current configuration'''
        self.root.save_to_file()

    # Get list of block storage objects
    def get_block_store_objects(self):
        self.block_store = {}
        for storage_object in self.root.storage_objects:
            if storage_object.plugin == "block":
                self.block_store[storage_object.name] = storage_object

    # Get a list of iscsi targets and associated luns, acls and portals
    # This builds a data structure that is a hash that hash other hashes
    # as values, and then other hashes, etc. To see what the data structure
    # looks like, run targetcli from the command line and issue the ls command.
    #
    # This data structure mimics that list for fast lookup for creating
    # shares for lots of nodes.
    #
    # This code is really confusing, in case you couldn't tell.
    #
    # target 0..N -> target.wwn
    # |
    # +---tpgs         List of target portal groups, this code assumes only one
    #      |           self.target[wwn]['tpg'][tpg.tag]['acl'][initiator_name']
    #                     = mapped_lun
    #      |
    #      +--acls     List of initiator names that can log into this iscsi
    #                  target
    #      |             self.target[wwn]['tpg'][tpg.tag]['acl'] = {
    #                        initiator_name : acl
    #                    }
    #      |
    #      +--luns     List of LUNS for this TPG
    #      |             self.target[wwn]['lun'][lun.storage_object.name] = lun
    #      |
    #      +--portals  List of portals for this TPG
    #        self.target[wwn]['portal'][portal.ip_address:portal.port] = portal

    # There can be any number of targets, each uniquely identified by its wwn
    #   (World Wide Name)  which is also known as the initiator name. This is
    #   the unique name assigned to each client. The client knows about this
    #   name either by looking at its kernel parameters, the initiator name
    #   stored in the BIOS, but usually in /etc/iscsi/initiatorname.iscsi
    #
    # self.target[wwn]['tpg']    [tpg.tag]  ['acl'] [initiator_name] =
    #                                MappedLUN object
    # self.target[wwn]['lun']    [lun_storage_object.name] = LUN object
    # self.target[wwn]['portal'] [portal_id] = Portal object
    #
    def get_targets(self):
        for target in list(self.iscsi.targets):
            wwn = target.wwn
            self.target[wwn] = {'target': target, 'tpg': {}}

            for tpg in target.tpgs:
                self.target[wwn]['tpg'][tpg.tag] = {
                    'tpg': tpg,
                    'acl': {},
                    'lun': {},
                    'portal': {}
                }

                tpg_tag = self.target[wwn]['tpg'][tpg.tag]

                for acl in tpg.node_acls:
                    tpg_tag['acl'][acl.node_wwn] = acl

                for lun in tpg.luns:
                    tpg_tag['lun'][lun.storage_object.name] = lun

                for portal in tpg.network_portals:
                    portal_id = portal.ip_address + ":" + str(portal.port)
                    tpg_tag['portal'][portal_id] = portal

    # Create a share
    def create_iscsi_target(self, params):
        """Create an iSCSI target

        Parameters
        ----------
        params : dict
            Dictionary of parameters
            wwn: The World Wide Name of the share, eg, the IQN
            device: the backing device
            initiators: list of initiators
        """
        wwn = params.get('wwn', None)
        device = params.get('device', None)
        initiators = params.get('initiators', None)
        ip = params.get('ip', '0.0.0.0')
        port = params.get('port', 3260)

        # Something outside this library lowercase the wwn, so
        # we lowercase the input to stay consistent
        if wwn is not None:
            wwn = wwn.lower()

        # If at any step, something needs to be created,
        # then true is returned to the caller to show that
        # this iscsi target needed to be created.
        #
        # It is possible to call this method for an existing
        # iscsi target, in which case this method does nothing
        #
        # By tracking this behavior, the caller can be informed
        # whether or not any action was taken
        created = None

        # Create blockstore, if needed
        blockstore = self.get_block_store(wwn)
        if blockstore is None:
            blockstore = self.create_block_store(wwn, device)
            created = True
        else:
            Log.info('block backstore %s already exists, not creating' % (wwn))

        # Create target
        target = self.get_target(wwn)
        if target is None:
            target = self.create_target(wwn)
            created = True
        else:
            Log.info('target %s already exists, not creating' % (wwn))

        # Create TPG
        tag = 1
        tpg = self.get_tpg(target, tag)
        if tpg is None:
            tpg = self.create_tpg(target, tag)
            created = True
        else:
            Log.info('tpg (%s, %s) already exists, not creating' %
                     (target, tag))

        # Create LUN

        # First, check to see if there are any LUNs. More than one LUN is not
        # supported, so we just iterate over all (eg, the one) lun and set it.
        # If there's more than one LUN, then the last one will be the LUN that
        # is used, which may result in undefined behavior
        lun = None
        for lun in tpg.luns:
            pass

        if lun is None:
            lun = self.create_lun(tpg, blockstore)
            created = True
        else:
            Log.info('lun %s already exists, not creating' % (blockstore.name))

        # Create portal
        portal = self.get_portal(tpg, ip, port)
        if portal is None:
            portal = self.create_portal(tpg, ip, port)
            created = True
        else:
            portal_id = self.get_portal_id(ip, port)
            Log.info('portal %s already exists, not creating' % (portal_id))

        # Set up ACLs and mapped LUNs
        for initiator in initiators:
            # Create ACL
            acl = self.get_acl(tpg, initiator)
            if acl is None:
                acl = self.create_acl(tpg, initiator)
                created = True
            else:
                Log.info('acl (%s, %s) already exists, not creating' %
                         (tpg, initiator))

            # Map LUN
            num = 0

            # Like with LUNs, only one mapped lun is supported. Check for
            # a mapped lun by iterating over the entire set of mapped luns,
            # use the last one in the list, if any exist.
            #
            # If things are working properly, there should be only one
            mapped_lun = None
            for mapped_lun in acl.mapped_luns:
                pass

            if mapped_lun is None:
                mapped_lun = self.create_mapped_lun(acl, num, lun)
                created = True
            else:
                Log.info('mapped lun (%s, %s, %s) already exists' %
                         (acl, num, lun))

        return created

    def delete_target_and_block_store(self, params):
        """Delete an iSCSI target and block store. This does not delete the
        underlying storage

        Parameters
        ----------
        target_wwn : string
            The world wide name of the share to remove
        """
        wwn = params.get('wwn', None)

        if wwn is None:
            raise ValueError('No wwn specified')

        # Delete target
        self.delete_target(wwn)

        # Delete blockstore
        self.delete_block_store(wwn)

    def get_block_store(self, wwn):
        """Get an existing block store, if it exists

        Parameters
        ----------
        wwn : string
            World Wide Name for the block store
        device : string
            Path to a block device

        Returns:
        --------
        If the block store exists, then that object is returned.
        Otherwise, None is returned
        """
        return self.block_store.get(wwn, None)

    def create_block_store(self, wwn, device):
        """Create a blockstore with the given wwn. It is assumed that the
        blockstore does not already exists. Calling this method when the
        storage already exists can potentially result in an exception being
        thrown. Call get_block_store first to check for existence.

        Parameters
        ----------
        wwn : string
            World Wide Name for the block store
        device : string
            Path to a block device

        Returns:
        --------
        blockstore object, if it was successfully created
        """
        Log.info('creating block backstore %s for device %s' % (wwn, device))
        storage = BlockStorageObject(wwn, device, wwn)
        self.block_store[wwn] = storage
        return storage

    # Delete blockstore, if it exists
    def delete_block_store(self, name):
        store = self.block_store.get(name)

        # If blockstore doesn't exist, do not proceed
        if store is None:
            Log.info('No block store %s. Not deleting' % name)
            return

        Log.info('deleting block store %s' % (name))

        # Delete the block store. The backing device, file, etc,  still exists
        store.delete()
        del self.block_store[name]

    # Delete target, if it exists
    def delete_target(self, wwn):
        # See if the target exists
        target_dict = self.target.get(wwn, None)

        # Doesn't exist, don't proceed
        if target_dict is None:
            Log.info('No target %s. Not deleting' % wwn)
            return

        target = target_dict.get('target', None)

        # Surprising, but possible, because processes can die
        # and the state can strange
        if target is None:
            return

        Log.info('deleting target %s' % (wwn))

        # Delete the target
        target.delete()
        del self.target[wwn]

    def get_target(self, wwn):
        '''Get an existing target object for the wwn

        Parameters
        ----------
        wwn : string
            The wwn of the target

        Returns
        -------
        The target object if it exists, None otherwise
        '''
        target_dict = self.target.get(wwn, None)
        target = None

        if target_dict is not None:
            target = target_dict['target']

        return target

    # Create target, if needed
    def create_target(self, wwn):
        target_dict = self.target.get(wwn, None)
        target = None

        if target_dict is None:
            Log.info('creating target with wwn %s' % (wwn))
            # The wwn will be lowercased automatically by something
            # outside this library. I'm not sure if its RTSLib or
            # the underlying Linux target system
            target = Target(self.iscsi, wwn)
            # Add target to data structure, initialize empty child nodes
            self.target[wwn] = {'target': target, 'tpg': {}}
        else:
            Log.info('target %s already exists, not creating' % (wwn))
            target = target_dict['target']

        return target

    def get_tpg(self, target, tag):
        '''Get a target portal group

        Parameters
        ----------
        target: Target
            The target
        tag: Tag
            The tag

        Returns
        -------
        The target portal group, if it exists, None otherwise
        '''
        tpg_list = self.target[target.wwn]['tpg']
        tpg_list_tag = tpg_list.get(tag, None)
        tpg = None

        if tpg_list_tag is not None:
            tpg = tpg_list[tag]['tpg']

        return tpg

    # Create TPG, if needed
    def create_tpg(self, target, tag):
        tpg_list = self.target[target.wwn]['tpg']
        tpg_list_tag = tpg_list.get(tag, None)

        if tpg_list_tag is None:
            Log.info('creating tpg (%s, %s)' % (target, tag))

            # Create and configure the target portal group
            tpg = TPG(target, tag)
            tpg.set_attribute("authentication", 0)
            tpg.enable = 1

            # Set up the list of TPGs for this target
            tpg_list[tag] = {
                'tpg': tpg,
                'acl': {'mapped_lun': {}},
                'lun': {},
                'portal': {}
            }
        else:
            Log.info('tpg (%s, %s) already exists, not creating' %
                     (target, tag))
            tpg = tpg_list[tag]['tpg']

        return tpg

    # Create LUN, if needed
    def create_lun(self, tpg, blockstore):
        wwn = tpg.parent_target.wwn
        lun_list = self.target[wwn]['tpg'][tpg.tag]['lun']
        lun = lun_list.get(blockstore.name, None)

        if lun is None:
            Log.info('creating lun %s, blockstore %s' % (tpg, blockstore))
            # Create the LUN
            lun = LUN(tpg, 0, blockstore)
            # Add it to the local data structure for tracking LUNs
            lun_list[blockstore.name] = lun
        else:
            # LUN already exists
            Log.info('lun %s already exists, not creating' % (blockstore.name))

        return lun

    def get_portal_id(self, ip, port):
        return '%s:%d' % (ip, port)

    def get_portal(self, tpg, ip, port):
        portal = None
        portal_id = self.get_portal_id(ip, port)
        wwn = tpg.parent_target.wwn
        portal_list = self.target[wwn]['tpg'][tpg.tag]['portal']
        return portal_list.get(portal_id, None)

    # Create portal, if needed
    def create_portal(self, tpg, ip, port):
        portal = None
        portal_id = self.get_portal_id(ip, port)
        wwn = tpg.parent_target.wwn
        portal_list = self.target[wwn]['tpg'][tpg.tag]['portal']

        if portal_id in portal_list:
            Log.info('portal %s already exists, not creating' % (portal_id))
            portal = portal_list[portal_id]
        else:
            Log.info('creating portal (%s, %s, %s)' % (tpg, ip, port))
            portal = NetworkPortal(tpg, ip, port)
            portal_list[portal_id] = portal

        return portal

    def get_acl(self, tpg, initiator_name):
        acl = None
        wwn = tpg.parent_target.wwn
        acl_list = self.target[wwn]['tpg'][tpg.tag]['acl']

        return acl_list.get(initiator_name, None)

    # Create ACL, if needed
    def create_acl(self, tpg, initiator_name):
        acl = None
        wwn = tpg.parent_target.wwn
        acl_list = self.target[wwn]['tpg'][tpg.tag]['acl']

        if initiator_name in acl_list:
            Log.info('acl (%s, %s) already exists, not creating' %
                     (tpg, initiator_name))
            acl = acl_list[initiator_name]
        else:
            Log.info('creating acl (%s, %s)' % (tpg, initiator_name))
            acl = NodeACL(tpg, initiator_name)
            acl_list[initiator_name] = acl

        return acl

    # Create mapped lun, if needed
    def create_mapped_lun(self, acl, num, lun):
        mapped_lun = None
        if not list(acl.mapped_luns):
            Log.info('creating mapped lun (%s, %s, %s)' % (acl, num, lun))
            mapped_lun = MappedLUN(acl, num, lun)
        else:
            Log.info('mapped lun (%s, %s, %s) already exists' %
                     (acl, num, lun))

        return mapped_lun
