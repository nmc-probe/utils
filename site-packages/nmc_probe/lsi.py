# Copyright (c) 2015 The New Mexico Consortium
# 
# {{{NMC-LICENSE
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.
#
# }}}

from nmc_probe.command import AsyncCommand, Command
from nmc_probe.log import Log
from nmc_probe.hdparm import HDParm
import json, re, os

sas2ircu_cmd='/usr/local/bin/sas2ircu'

class LSI:
    '''Interface to LSI sas2ircu command'''

    @property
    def serial_number_to_attrs(self):
        if getattr(self, '_serial_number_to_attrs', None) is None:
            _serial_number_to_attrs = {}
            for (position, attrs) in self.disks.iteritems():
                _serial_number_to_attrs[attrs['serial_number']] = attrs

        return _serial_number_to_attrs

    @property
    def controllers(self):
        '''List of LSI controllers and their parameters'''
        if getattr(self, '_controllers', None) is None:
            self._controllers = self.list_controllers()
        return self._controllers

    @property
    def disks(self):
        '''List of disks attached to the LSI controllers'''
        if getattr(self, '_disks', None) is None:
            self._disks = self.list_disks()
        return self._disks

    def list_controllers(self):
        '''Get the list of controllers'''
        controllers = {}
        sas2ircu = AsyncCommand([sas2ircu_cmd, 'list'])

        while not sas2ircu.eof:
            while not sas2ircu.queue.empty():
                line = sas2ircu.queue.get()
                if re.match('^\s+[0-9]+\s+\w+.*', line):
                    parts = line.split()
                    controllers[parts[0]] = {
                        'type':          parts[1],
                        'vendor_id':     parts[2],
                        'device_id':     parts[3],
                        'pci_address':   self.extract_pci_address(parts[4]),
                        'subsys_ven_id': parts[5],
                        'subsys_dev_id': parts[6]
                    }

        return controllers

    def list_disks(self):
        '''Get the list of disks as an array of dictionaries'''
        disks = {}

        hard_drive_attrs = {
            'Enclosure #': 'enclosure',
            'Slot #': 'slot',
            'SAS Address': 'sas_address',
            'Serial No': 'serial_number',
            'State': 'state',
            'Size (in MB)/(in sectors)': 'size',
            'Manufacturer': 'manufacturer',
            'Firmware Revision': 'firmware',
            'GUID': 'guid',
            'Protocol': 'protocol',
            'Drive Type': 'drive_type'
        }

        last_attr = 'Drive Type'
        serial_number_attr = 'Serial No'

        attrs = {}
        parse_hdd = None

        for controller in self.controllers:
            sas2ircu = AsyncCommand([sas2ircu_cmd, controller, 'display'])

            while not sas2ircu.eof:
                while not sas2ircu.queue.empty():
                    line = sas2ircu.queue.get()

                    if re.match('^Device is a Hard disk', line):
                        parse_hdd = True
                        attrs = {}
                    else:
                        
                        if parse_hdd:
                            for (match_attr, attr) in hard_drive_attrs.iteritems():
                                pattern = '^\s+%s\s+:\s+(.*)\s*$' % match_attr
                                match = re.match(pattern, line)
                                
                                if match is not None:
                                    attrs[attr] = match.group(1)

                                    if attr == 'sas_address':
                                        attrs[attr] = self.extract_sas_address(attrs[attr])

                                    if attr == 'serial_number':
                                        attrs[attr] = self.fix_serial_number(attrs[attr])

                                    if match_attr == last_attr:
                                        parse_hdd = None
                                        key = '%s:%s' % (attrs['enclosure'], attrs['slot'])

#                                        attrs['dev_by_path'] = self.disk_by_path(controller, attrs)
#                                        attrs['dev'] = os.path.realpath(attrs['dev_by_path'])
                                        
#                                        hdparm = HDParm(attrs['dev'])
#                                        attrs.update(hdparm.info)

#                                        if attrs.get('wwn', None) is not None:
#                                            attrs['dev_by_id_wwn'] = self.disk_by_id_wwn(attrs)

#                                        attrs['dev_by_id_protocol'] = self.disk_by_id_protocol(attrs)
                                        disks[key] = attrs
                                        
        return disks

    def disk_by_id_wwn(self, attrs):
        '''Find the /dev/disk/by-id/dev_name based on the protocol, 
        model number and serial number'''
        wwn = attrs.get('wwn', None)

        if wwn is None:
            print attrs
            raise Exception('No wwn attribute, cannot find /dev/disk/by-id/wwn-')

        dev = '/dev/disk/by-id/wwn-0x%s' % wwn

        # Check to see if the device exists. If it doesn't, an exception will be 
        # thrown
        os.stat(dev)
        return dev

    def disk_by_id_protocol(self, attrs):
        '''Find the /dev/disk/by-id/dev_name based on the protocol, 
        model number and serial number'''

        protocol = attrs.get('protocol', None)
        serial_number = attrs.get('serial_number', None)
        model_number = attrs.get('model_number', None)

        path = '/dev/disk/by-id/%s-%s-%s'

        if protocol is None:
            raise Exception('No protocol specified, cannot find /dev/disk/by-id/PROTOCOL')

        if serial_number is None:
            raise Exception('No serial_number for drive, cannot find /dev/disk/by-id')

        if model_number is None:
            raise Exception('No model_number number for drive, cannot find /dev/disk/by-id')

        model_number = model_number.replace(' ', '_')
        serial_number = serial_number.replace(' ', '_')

        # Replace spaces in model number with 
        if protocol == 'SATA':
            protocol = 'ata'
        elif protocol == 'SAS':
            protocol = 'sas'
        else:
            raise Exception('Protocol %s not recognized, cannot find /dev/disk/by-id/PROTOCOL')

        dev = '/dev/disk/by-id/%s-%s_%s' % (protocol, model_number, serial_number)

        # Check to see if the device exists. If it doesn't, an exception will be 
        # thrown
        os.stat(dev)
        return dev

    def disk_by_path(self, controller, attrs):
        '''Find the /dev/disk/by-path/ based on the controller pci address
        and the disk's sas address'''

        # Verify that all information needed to generate the device name exists
        sas_address = attrs.get('sas_address', None)
        controller_attrs = self.controllers.get(controller, None)

        if sas_address is None:
            raise Exception('No sas_address attribute, cannot find /dev/disk/by-path')

        if controller_attrs is None:
            raise Exception('No controller attributes for controller %s. Perhaps that controller does not exist?' % controller)

        pci_address = self.controllers[controller].get('pci_address', None)

        if pci_address is None:
            raise Exception('Controller %s does not have a pci_address attribute' % controller)

        # Generate the device name
        dev = '/dev/disk/by-path/pci-%s-sas-0x%s-lun-0' % (pci_address, sas_address)

        # Verify device exists. Exception will be thrown if not
        os.stat(dev)
        return dev
           
    def fix_serial_number(self, serial_number):
        '''The serial numbers get munged by sas2ircu, for example, 
        WD-WCATR6750977 turns into WDWCATR6750977. Put the dash back in'''
        
        patterns = {
            'WD(.*)$': 'WD-%s',
        }

        for (pattern, fmt) in patterns.iteritems():
            match = re.match(pattern, serial_number)
            if match is not None:
                return fmt % match.groups()

        # Default, return serial number unchanged
        return serial_number

    def extract_pci_address(self, pci_address):
        '''Converts a PCI address of format 00h:07h:00h:00h to 0000:07:00.0'''
        hex = "[0-9a-fA-F]"
        match = re.match('(%s+)h:(%s+)h:(%s+)h:(%s+)h' % (hex, hex, hex, hex), pci_address)
        if match is not None:
            parts = []
            for piece in match.groups():
                parts.append(int(piece, 16))

            return '%04x:%02x:%02x.%x' % (parts[0], parts[1], parts[2], parts[3])
        
        return pci_address

    def extract_sas_address(self, sas_address):
        '''Remove dashes from a sas address'''
        return sas_address.replace('-', '')
