# Copyright (c) 2015 The New Mexico Consortium
# 
# {{{NMC-LICENSE
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.
#
# }}}

import os,subprocess,log,sys,re
from subprocess import PIPE,Popen
import threading, time, Queue
from nmc_probe.log import Log

class Command:
    """                                                                         
    Wrapper class for subprocess. Checks for exceptions                         
    and logs the errors                                                         

    Returns
    -------
    A tuple: (all output, exit code)
    """
    @classmethod
    def run(cls, args):
        output = None
        exitCode = 0
        try:
            Log.debug(100, ' '.join(args))
            proc = Popen(args, stdout=PIPE)
            output = proc.communicate()[0].split('\n')
            exitCode = proc.returncode
        except (OSError) as e:
            Log.error(str(e))

        return (output, exitCode)

    @classmethod
    def run_and_extract_attrs(cls, args, attr_patterns):
        (output, exitcode) = Command.run(args)
        
        attr_list = {}

        for line in output:
            for (pattern, attr) in attr_patterns.iteritems():
                match = re.match(pattern, line)
                
                if match is not None:
                    if len(match.groups()) >= 1:
                        attr_list[attr] = match.group(1)

        return attr_list

class AsynchronousFileReader(threading.Thread):
    '''
    Helper class to implement asynchronous reading of a file
    in a separate thread. Pushes read lines on a queue to
    be consumed in another thread.

    http://stefaanlippens.net/python-asynchronous-subprocess-pipe-reading
    '''
 
    def __init__(self, fd, queue):
        assert isinstance(queue, Queue.Queue)
        assert callable(fd.readline)
        threading.Thread.__init__(self)
        self._fd = fd
        self._queue = queue
 
    def run(self):
        '''The body of the tread: read lines and put them on the queue.'''
        for line in iter(self._fd.readline, ''):
            self._queue.put(line)
 
    def eof(self):
        '''Check whether there is no more content to expect.'''
        return not self.is_alive() and self._queue.empty()

class AsyncCommand(threading.Thread):
    def __init__(self, command):
        self.command = command
        self.queue = Queue.Queue()
        threading.Thread.__init__(self)
        self.start()

    def run(self):
        # Launch the command as subprocess.
        process = subprocess.Popen(self.command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
 
        # Launch the asynchronous readers of the process' stdout and stderr.
        stdoutQueue = Queue.Queue()
        stdoutReader = AsynchronousFileReader(process.stdout, stdoutQueue)
        stdoutReader.start()
        stderrQueue = Queue.Queue()
        stderrReader = AsynchronousFileReader(process.stderr, stderrQueue)
        stderrReader.start()

        # Check the queues if we received some output (until there is nothing more to get).
        while not stdoutReader.eof() or not stderrReader.eof():
            # Show what we received from standard output.
            while not stdoutQueue.empty():
                line = stdoutQueue.get()
                self.queue.put(line.rstrip())
 
            # Show what we received from standard error.
            while not stderrQueue.empty():
                line = stderrQueue.get()
                print 'Received line on standard error: ' + repr(line)
 
            # Sleep a bit before asking the readers again.
            time.sleep(.1)
 
        # Let's be tidy and join the threads we've started.
        stdoutReader.join()
        stderrReader.join()
 
        # Close subprocess' file descriptors.
        process.stdout.close()
        process.stderr.close()


    @property
    def eof(self):
        '''Check whether there is no more content to expect.'''
        return not self.is_alive() and self.queue.empty()
