# Copyright (c) 2015 The New Mexico Consortium
# 
# {{{NMC-LICENSE
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.
#
# }}}

# Flask imports
from flask import Flask, jsonify
from flask.ext.restful import Api, Resource, reqparse

# nmc_probe imports
from nmc_probe.target_manager import TargetManager
from nmc_probe.zfs import ZFS
from nmc_probe.log import Log

import traceback

import sqlalchemy as sa
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy import create_engine
from sqlalchemy_utils import UUIDType, JSONType, ChoiceType, Timestamp
import uuid

Base = declarative_base()

class LUNCloneDetails(Base, Timestamp):
    status_types = [('pending', 'pending'),
                    ('in_progress', 'in_progress'),
                    ('finished', 'finished')]
    job_types = [('create', 'create'),
                 ('delete', 'delete')]

    __tablename__ = 'lun_clone_details'
#    id = sa.Column(UUIDType(binary=False), primary_key=True)
#    status = sa.Column(ChoiceType(status_types))
#    job_type = sa.Column(ChoiceType(job_types))
#    num_actions = sa.Column(sa.Integer, default = 0)
#    num_completed = sa.Column(sa.Integer, default = 0)
#    percent_completed = sa.Column(sa.Float, default = 0)
#    error = sa.Column(sa.Unicode(2048))
    details = sa.Column(JSONType)

# Create an engine that stores data in the local directory's                                        engine = create_engine('sqlite:///lun_clone.db')

# Create tables
Base.metadata.create_all(engine)

class LUNCloneTest(Resource):
    def get(self):
        return {'status': 'ok',
                'message': 'test'}

class LUNClone(Resource):
    # TODO: can this method be deleted?
    def create(self, zfs, mgr, args):
        created_clone = None
        created_target = None
        # Create the ZFS clone
        created_clone = zfs.clone(args)
        # Create the iSCSI target
        args['device'] = '/dev/zvol/%s' % args['dst']
        created_target = mgr.create_iscsi_target(args)

        if created_clone is not None:
            return True
        return None

    def create_zfs(self, zfs, args):
        created_clone = None
        # Create the ZFS clone
        created_clone = zfs.clone(args)

        if created_clone is not None:
            return True
        return None

    def create_target(self, mgr, args):
        created = None
        # Create the iSCSI target
        args['device'] = '/dev/zvol/%s' % args['dst']
        created = mgr.create_iscsi_target(args)

        if created is not None:
            return True
        return None

    # TODO: can this method be deleted?
    def remove(self, zfs, mgr, args):
        # If deleteClones = true, then the dst parameter is also required.
        deleteClones = args.get('deleteClones', None)
        
        if deleteClones:
            if args.get('dst', None) is None:
                message = {'message': 'deleteClones parameter requires dst parameter'}
                return {'status': message}, 404

        mgr.delete_target_and_block_store(args)

        if deleteClones is not None:
            zfs.destroy(args)

    def remove_target(self, mgr, args):
        mgr.delete_target_and_block_store(args)

    def remove_zfs(self, zfs, args):
        # If deleteClones = true, then the dst parameter is also required.
        deleteClones = args.get('deleteClones', None)
        
        if deleteClones:
            if args.get('dst', None) is None:
                message = {'message': 'deleteClones parameter requires dst parameter'}
                return {'status': message}, 404

            zfs.destroy(args)

    def post(self):
        try:
            # Parse the arguments
            args = self.array_parser.parse_args()
            lun_clone = LUNCloneDetails(details = args)

        except (Exception), e:
            Log.error('%s:\n%s' % (str(e), traceback.format_exc()))
            return {'status': str(e),
                    'stacktrace': traceback.format_exc()}, 501
        
        return {'status': 'ok', 'created': created}, 201

    def post_old(self):
        try:
            # Parse the arguments
            args = self.array_parser.parse_args()

            # Set up ZFS and Target management
            zfs = ZFS()
            mgr = TargetManager()
            created = []

            for arg in args['clones']:
                if self.create_zfs(zfs, arg):
                    created.append(arg['dst'])

            if len(created) > 0:
                zfs.udevd_settle_down()

            for arg in args['clones']:
                self.create_target(mgr, arg)

        except (Exception), e:
            Log.error('%s:\n%s' % (str(e), traceback.format_exc()))
            return {'status': str(e),
                    'stacktrace': traceback.format_exc()}, 501
        
        return {'status': 'ok', 'created': created}, 201

    def delete_old(self):
        try:
            args = self.array_parser.parse_args()

            # Set up ZFS and Target management
            zfs = ZFS()
            mgr = TargetManager()

            for arg in args['clones']:
                self.remove_target(mgr, arg)

            for arg in args['clones']:
                self.remove_zfs(zfs, arg)

        except (Exception), e:
            Log.error('%s:\n%s' % (str(e), traceback.format_exc()))
            return {'status': str(e),
                    'stacktrace': traceback.format_exc()}, 501

        return {'status': 'ok'}, 201

    @property
    def post_parser(self):
        if getattr(self, '_post_parser', None) is None:
            parser = reqparse.RequestParser()
            parser.add_argument('src', type=str, location='json')
            parser.add_argument('dst', type=str, location='json')
            parser.add_argument('properties', type=dict, location='json')
            parser.add_argument('createParent', type=bool, location='json')
            parser.add_argument('wwn', type=str, location='json')
            parser.add_argument('initiators', type=list, location='json')
            self._post_parser = parser

        return self._post_parser

    @property
    def array_parser(self):
        if getattr(self, '_post_array_parser', None) is None:
            self._array_parser = reqparse.RequestParser()
            self._array_parser.add_argument('clones', type=list, location='json')
        return self._array_parser

    @property
    def delete_parser(self):
        if getattr(self, '_delete_parser', None) is None:
            self._delete_parser = reqparse.RequestParser()
            self._delete_parser.add_argument('dst', type=str, location='json')
            self._delete_parser.add_argument('target_wwn', type=str, location='json')
            self._delete_parser.add_argument('deleteClones', type=str, location='json')
        return self._delete_parser
